% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app-process.R
\name{new_app_process}
\alias{new_app_process}
\alias{presser_app_process}
\title{Run a presser app in another process}
\usage{
new_app_process(
  app,
  ...,
  .port = NULL,
  .num_threads = 1,
  .process_timeout = 5000
)
}
\arguments{
\item{app}{\code{presser_app} object, the web app to run.}

\item{...}{Options to pass to the \code{\link[callr:r_session_options]{callr::r_session_options()}} when
setting up the subprocess.}

\item{.port}{Port to use. By default the OS assigns a port.}

\item{.num_threads}{the number of threads that will handle HTTP
requests. If you use asynchronous or parallel HTTP requests, then
you probably want to increase this, to let the server handle
multiple requests at the same time.}

\item{.process_timeout}{How long to wait for the subprocess to start, in
milliseconds.}
}
\value{
A \code{presser_app_process} class.
\subsection{Methods}{

The \code{presser_app_process} class has the following methods:\if{html}{\out{<div class="r">}}\preformatted{get_app()
get_port()
stop()
get_state()
url(path = "/", query = NULL)
}\if{html}{\out{</div>}}
\itemize{
\item \code{path}: Path to return the URL for.
\item \code{query}: Additional query parameters, a named list, to add to the URL.
}

\code{get_app()} returns the app object.

\code{get_port()} returns the port the web server is running on.

\code{stop()} stops the web server, and also the subprocess.

\code{get_state()} returns a string, the state of the web server:
\itemize{
\item \code{"not running"} the server is not running (because it was stopped
already).
\item \code{"live"} means that the server is running.
\item \code{"dead"} means that the subprocess has quit or crashed.
}

\code{url()} returns the URL of the web app. You can use the \code{path}
parameter to return a specific path.
}
}
\description{
Runs an app in a subprocess, using \link[callr:r_session]{callr::r_session}.
}
\examples{
app <- new_app()
app$get("/foo", function(req, res) {
  res$send("Hello world!")
})

proc <- new_app_process(app)
url <- proc$url("/foo")
resp <- curl::curl_fetch_memory(url)
cat(rawToChar(resp$content))

proc$stop()
}

---
title: "OAuth2.0 webfakes app"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{oauth}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(webfakes)
```

```{r child='../man/rmd-fragments/oauth2.Rmd'} 
```

In this vignette, we shall look at how to implement a flow using both apps, or the server app together with httr's OAuth tools.
In both cases we shall use the httr package as HTTP client.
For an example using the curl package instead, look at the test file `test-oauth.R` of webfakes instead.

## In all cases: create the resource server

First we need to create the resource server, and we create variables holding its different URLs.


```{r resource-server-creation}
templog <- tempfile()
rsapp <- local_app_process(
  oauth2_resource_app(
    refresh_duration = 9999999999999999L, 
    access_duration = 10L,
    stream = templog
    ),
  opts = server_opts(num_threads = 3)
)

rsapp

regi_url <- rsapp$url("/register")
auth_url <- rsapp$url("/authorize")
toke_url <- rsapp$url("/token")
```

## Without httr's OAuth tools

### OAuth2.0 app creation & registration

Then we create the third-party app, and we create variables holding its different URLs.

```{r third-party-app-creation}
tpapp <- local_app_process(
  oauth2_third_party_app("3P app"),
  opts = server_opts(num_threads = 3)
)

tpapp

redi_url <- tpapp$url("/login/redirect")
conf_url <- tpapp$url("/login/config")
```

We then need to register the third-party app at the resource server.
In real life this is done by the admin of the third party app

```{r register}
url <- paste0(
  regi_url,
  "?name=3P%20app",
  "&redirect_uri=", redi_url
)
reg_resp <- httr::GET(url)
reg_resp
regdata <- httr::content(reg_resp)
regdata
```

Now we set this data on the third-party app
In real life this is included in the config of the third party app
by its admin.

```{r register-data}
auth_data <- list(
  auth_url = auth_url,
  token_url = toke_url,
  client_id = regdata$client_id[[1]],
  client_secret = regdata$client_secret[[1]]
)

httr::POST(
  conf_url,
  body = auth_data,
  encode = "json"
)

```

## OAuth2.0 dance

At this state an user can `browseURL(tpapp$url("/login"))` and allow the third-party app access to their account.
Once they have done that they get a token in the browser.
You can try that interactively, and refer to the test file `test-oauth.R` to see a programmatic version of the clicking.

Once the OAuth2.0 dance is finished in the browser you see the tokens the resource app produced, returned by the third-party app.
The third-party app also saved the tokens to its own environment.
You can change what appears in the browser.


```{r hook}
thirdp <- oauth2_third_party_app("3P app")
thirdp$redirect_hook <- function(res, tokens) {
  res$
    set_status(200L)$
    send("Authentication complete, return to R!")
}

tpapp2 <- local_app_process(
  thirdp,
  opts = server_opts(num_threads = 3)
)

tpapp2

redi_url <- tpapp2$url("/login/redirect")
conf_url <- tpapp2$url("/login/config")
url <- paste0(
  regi_url,
  "?name=3P%20app2",
  "&redirect_uri=", redi_url
)
reg_resp <- httr::GET(url)
reg_resp
regdata <- httr::content(reg_resp)
regdata
auth_data <- list(
  auth_url = auth_url,
  token_url = toke_url,
  client_id = regdata$client_id[[1]],
  client_secret = regdata$client_secret[[1]]
)

httr::POST(
  conf_url,
  body = auth_data,
  encode = "json"
)
```

Then again `browseURL(tpapp2$url("/login"))` and `httr::content(httr::GET(tpapp2$url("/locals")))` to 
see the saved tokens.
Now the third-party app can get data on your behalf (the whole goal of OAuth!) --- it could also post data on your behalf if the resource app had endpoints for that.
In real life, access by the third-party app might be limited to some scopes, but the apps shipped with webfakes do not handle that.

```{r, eval = FALSE}
httr::content(httr::GET(tpapp2$url("/data")))
```

## With httr's OAuth tools

When you use httr's OAuth tool, there's some gymnastics happening as R is playing the role of a third-party app via httr and httpuv (to listen to the redirect URI).

### OAuth2.0 app creation & registration

What's crucial here is setting `httr::oauth_callback()` as redirect URI, which is what you do when creating an app for rtweet for instance.

``` {r httr}
url <- paste0(
  regi_url,
  "?name=3P%20app2",
  "&redirect_uri=", httr::oauth_callback()
)
reg_resp <- httr::GET(url)
reg_resp
regdata <- httr::content(reg_resp)
regdata
```

Now we set the registration data on the third-party app.

```{r httr-dance}
app <- httr::oauth_app(
  "3P app2",
  key = regdata$client_id[[1]],
  secret = regdata$client_secret[[1]],
  redirect_uri = httr::oauth_callback()
)

endpoint <- httr::oauth_endpoint(
  authorize = auth_url,
  access = toke_url
)
```


Now we can launch the token creation.
This can only be done interactively

```{r httr-dance2, eval = FALSE}
file.remove(file.path("vignettes", "token.rds"))
token <- httr::oauth2.0_token(
  endpoint, app,
  cache = FALSE
)

saveRDS(token, file = file.path("vignettes", "token.rds"), version = 2)

```

Below we use the token that we cached when creating the vignette (and whose refresh token is valid forever).

```{r get-token, echo = TRUE}
# to make sure the app has our access and refresh tokens
httr::GET(rsapp$url("/noninteractive"))

# reading the credentials of the cached token
# and creating an httr token whose URLs are those of the app at hand
token <- readRDS("token.rds")
token <- httr::oauth2.0_token(
  endpoint = endpoint,
  app = app,
  credentials = token$credentials
)
```


```{r refresh, error = TRUE}
# Not authorized, since we provide no token
httr::GET(rsapp$url("/data"))

# We'll get data, the token will be refreshed automatically
httr::content(httr::GET(rsapp$url("/data"), config = token))

```

## Applications

With these apps, or only the resource server app, you can now test your code that helps users create and store an OAuth2.0 token.

Like all webfakes apps, OAuth2.0 apps are extensible: you can add your own endpoints to it. E.g.

```{r}
rsapp2 <- oauth2_resource_app(
    refresh_duration = 9999999999999999L, 
    access_duration = 10L,
    stream = templog
    )
rsapp2$get("/docs", function(req, res) {
  res$
    set_status(200L)$
    send("See vignette('oauth', package = 'webfakes')")
})

rsapp2_process <- local_app_process(
  rsapp2,
  opts = server_opts(num_threads = 3)
)

httr::content(httr::GET(rsapp2_process$url("/docs")))
```

If you want to customize one of the apps or both apps a lot, it might make sense to use their source code as starting point or inspiration.

## Debugging

On top of the [usual debugging advice for webfakes apps](https://r-lib.github.io/webfakes/dev/articles/how-to.html#how-can-i-debug-an-app-), the apps have (exemplified below for the resource app)

* an argument `stream` letting you write the log to a file. Here we wrote to `templog`.

```{r log}
readLines(templog)
file.remove(templog)
``` 

* an endpoint `/locals` that lets you see the current access and refresh tokens.

```{r}
httr::content(
  httr::GET(rsapp$url("/locals"))
)
```

## Conclusion

The webfakes package's two OAuth2.0 apps allow you to imitate an OAuth2.0 simplified workflow.
You might use both, or only the server one.
The apps also exemplify the power of webfakes. 
You could create apps imitating an OAuth1.0 flow, or whatever your tests might warrant.
Do not hesitate to report your custom use cases via opening an issue.



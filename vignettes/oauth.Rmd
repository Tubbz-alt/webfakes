---
title: "OAuth2.0 webfakes apps"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{oauth}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: sentence
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(webfakes)
```

```{r child='../man/rmd-fragments/oauth2.Rmd'}
```

In this vignette, we shall look at how to implement a flow using both apps, or the server app together with httr's OAuth tools.
In both cases we shall use the httr package as HTTP client.
For an example using the curl package instead, look at the test file `test-oauth.R` of webfakes instead.

## In all cases: create the resource server

First we need to create the resource server, and we create variables holding its different URLs.

```{r resource-server-creation}
templog <- tempfile()
rsapp <- new_app_process(
  oauth2_resource_app(
    refresh_duration = .Machine$integer.max,
    access_duration = 10L,
    stream = templog
    ),
  opts = server_opts(num_threads = 3)
)

regi_url <- rsapp$url("/register")
auth_url <- rsapp$url("/authorize")
toke_url <- rsapp$url("/token")

rsapp
```

## Without httr's OAuth tools

### OAuth2.0 app creation & registration

Then we create the third-party app, and we create variables holding its different URLs.

```{r third-party-app-creation}
tpapp <- new_app_process(
  oauth2_third_party_app("3P app"),
  opts = server_opts(num_threads = 3)
)

redi_url <- tpapp$url("/login/redirect")
conf_url <- tpapp$url("/login/config")

tpapp
```

We then need to register the third-party app at the resource server.
In real life this is done by the admin of the third party app.
Our fake resource server provides an endpoint at `/register` (in `regi_url`) to do this automatically, without user interaction.
We need to send the name of our third party app, and its redirect URL, as query parameters.

```{r register}
url <- paste0(
  regi_url,
  "?name=3P%20app",
  "&redirect_uri=", redi_url
)
reg_resp <- httr::GET(url)
reg_resp
regdata <- httr::content(reg_resp)
regdata
```

The resource app replies with the client id and the client secret.
We'll use them to authenticate the third party app.
In real life they are included in the config of the third party app by its admin.
Our third party app has an API endpoint, `/login/config` (already in `conf_url`) to configure them.

```{r register-data}
auth_data <- list(
  auth_url = auth_url,
  token_url = toke_url,
  client_id = regdata$client_id[[1]],
  client_secret = regdata$client_secret[[1]]
)

httr::POST(
  conf_url,
  body = auth_data,
  encode = "json"
)
```

## OAuth2.0 dance

Now a user can go to the login URL of the third party app, `/login` in our fake app, to authenticate.
To start the web page from R, you can run

```{r eval = FALSE}
browseURL(tpapp$url("/login"))
```

```{r include = FALSE}
login <- oauth2_login(tpapp$url("/login"))
```

The third party app now has a token, that it can use to authenticate to the resource app.
See the `test-oauth.R` file within webfakes to see how to do this part programmatically, without a browser.

By default our fake third party app saves the token(s) into a local variable, and also returns in JSON, so you can see that in the browser:

```{r echo = FALSE}
cat(rawToChar(login$token_response$content))
```

If you want to change this behavior, you can define the `redirect_hook` function in the third party app.
For example:

```{r hook}
thirdp <- oauth2_third_party_app("3P app")
thirdp$redirect_hook <- function(res, tokens) {
  res$
    set_status(200L)$
    send("Authentication complete, return to R!")
}

tpapp2 <- new_app_process(
  thirdp,
  opts = server_opts(num_threads = 3)
)

redi_url2 <- tpapp2$url("/login/redirect")
conf_url2 <- tpapp2$url("/login/config")

tpapp2

url2 <- paste0(
  regi_url,
  "?name=3P%20app2",
  "&redirect_uri=", redi_url2
)
reg_resp2 <- httr::GET(url2)
reg_resp2
regdata2 <- httr::content(reg_resp2)
regdata2
auth_data2 <- list(
  auth_url = auth_url,
  token_url = toke_url,
  client_id = regdata2$client_id[[1]],
  client_secret = regdata2$client_secret[[1]]
)

httr::POST(
  conf_url2,
  body = auth_data2,
  encode = "json"
)
```

Then again you can authenticate at the new app with

```{r eval = FALSE}
browseURL(tpapp2$url("/login"))
```

```{r include = FALSE}
login2 <- oauth2_login(tpapp2$url("/login"))
```

The fake third party app also has an endpoint to return the saved tokens:

```{r}
httr::content(httr::GET(tpapp2$url("/locals")))
```

Now the third-party app can get data on your behalf (the whole goal of OAuth!) --- it could also post data on your behalf if the resource app had endpoints for that.

For example the `/data` endpoint of the third party app queries the resource app and needs authentication.
If you run the following without the OAuth dance, your access is denied.
But now it works fine:

```{r}
httr::content(httr::GET(tpapp2$url("/data")))
```

In real life, access by the third-party app might be limited to some scopes, but the fake apps shipped with webfakes do not handle that.

## With httr's OAuth tools

When you use httr's OAuth tool, there's some gymnastics happening as R is playing the role of a third-party app via httr and httpuv (to listen to the redirect URI).

### OAuth2.0 app creation & registration

What's crucial here is setting `httr::oauth_callback()` as redirect URI, which is what you do when creating an app for rtweet for instance.

```{r httr}
url3 <- paste0(
  regi_url,
  "?name=3P%20app2",
  "&redirect_uri=", httr::oauth_callback()
)
reg_resp3 <- httr::GET(url3)
reg_resp3
regdata3 <- httr::content(reg_resp3)
regdata3
```

Now we set the registration data on the third-party app.

```{r httr-dance}
app <- httr::oauth_app(
  "3P app2",
  key = regdata3$client_id[[1]],
  secret = regdata3$client_secret[[1]],
  redirect_uri = httr::oauth_callback()
)

endpoint <- httr::oauth_endpoint(
  authorize = auth_url,
  access = toke_url
)
```

Now we can launch the token creation.
For this example we store the token in a temporary file.
This is what you would typically do in test cases as well.
(Unlike real tokens, which you would ideally store at a secure place, like the system's credential store via the keyring package.)

```{r httr-dance2}
token <- oauth2_httr_login(
  httr::oauth2.0_token(endpoint, app, cache = FALSE)
)
```

```{r}
token_cache <- tempfile("webfakes-", fileext = ".rds")
saveRDS(token, file = token_cache)
```

Below we use the token that we cached when creating the vignette (and whose refresh token is valid forever).

```{r get-token, echo = TRUE}
# to make sure the app has our access and refresh tokens
httr::GET(rsapp$url("/noninteractive"))

# reading the credentials of the cached token
# and creating an httr token whose URLs are those of the app at hand
token <- readRDS("token.rds")
token <- httr::oauth2.0_token(
  endpoint = endpoint,
  app = app,
  credentials = token$credentials
)
```

```{r refresh, error = TRUE}
# Not authorized, since we provide no token
httr::GET(rsapp$url("/data"))

# We'll get data, the token will be refreshed automatically
httr::content(httr::GET(rsapp$url("/data"), config = token))

```

## Applications

With these apps, or only the resource server app, you can now test your code that helps users create and store an OAuth2.0 token.

Like all webfakes apps, OAuth2.0 apps are extensible: you can add your own endpoints to it.
E.g.

```{r}
rsapp2 <- oauth2_resource_app(
    refresh_duration = .Machine$integer.max,
    access_duration = 10L,
    stream = templog
    )
rsapp2$get("/docs", function(req, res) {
  res$
    set_status(200L)$
    send("See vignette('oauth', package = 'webfakes')")
})

rsapp2_process <- new_app_process(
  rsapp2,
  opts = server_opts(num_threads = 3)
)

httr::content(httr::GET(rsapp2_process$url("/docs")))
```

If you want to customize one of the apps or both apps a lot, it might make sense to use their source code as starting point or inspiration.

## Debugging

On top of the [usual debugging advice for webfakes apps](https://r-lib.github.io/webfakes/dev/articles/how-to.html#how-can-i-debug-an-app-), the apps have (exemplified below for the resource app)

-   an argument `stream` letting you write the log to a file. Here we wrote to `templog`.

```{r log}
readLines(templog)
file.remove(templog)
```

-   an endpoint `/locals` that lets you see the current access and refresh tokens.

```{r}
httr::content(
  httr::GET(rsapp$url("/locals"))
)
```

## Conclusion

The webfakes package's two OAuth2.0 apps allow you to imitate an OAuth2.0 simplified workflow.
You might use both, or only the server one.
The apps also exemplify the power of webfakes.
You could create apps imitating an OAuth1.0 flow, or whatever your tests might warrant.
Do not hesitate to report your custom use cases via opening an issue.

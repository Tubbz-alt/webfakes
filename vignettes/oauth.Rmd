---
title: "OAuth2.0 webfakes app"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{oauth}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(webfakes)
```

```{r child='../man/rmd-fragments/oauth2.Rmd'} 
```

In this vignette, we shall look at how to implement a flow using both apps, or the server app together with httr's OAuth tools.
In both cases we shall use the httr package as HTTP client.
For an example using the curl package instead, look at the test file `test-oauth.R` of webfakes instead.

## In all cases: create the resource server

First we need to create the resource server, and we create variables holding its different URLs.

```{r resource-server-creation}
rsapp <- local_app_process(
  oauth2_resource_app(),
  opts = server_opts(num_threads = 3)
)

rsapp

regi_url <- rsapp$url("/register")
auth_url <- rsapp$url("/authorize")
toke_url <- rsapp$url("/token")
```

## Without httr's OAuth tools

### OAuth2.0 app creation & registration


Then we create the third-party app, and we create variables holding its different URLs.

```{r third-party-app-creation}
tpapp <- local_app_process(
  oauth2_third_party_app("3P app"),
  opts = server_opts(num_threads = 3)
)

tpapp

redi_url <- tpapp$url("/login/redirect")
conf_url <- tpapp$url("/login/config")
```

We then need to register the third-party app at the resource server.
In real life this is done by the admin of the third party app


```{r register}
url <- paste0(
  regi_url,
  "?name=3P%20app",
  "&redirect_uri=", redi_url
)
reg_resp <- httr::GET(url)
reg_resp
regdata <- httr::content(reg_resp)
regdata
```

Now set this data on the third-party app
In real life this is included in the config of the third party app
by its admin.

```{r register-data}
auth_data <- list(
  auth_url = auth_url,
  token_url = toke_url,
  client_id = regdata$client_id[[1]],
  client_secret = regdata$client_secret[[1]]
)

httr::POST(
  conf_url,
  body = auth_data,
  encode = "json"
)

```

## OAuth2.0 dance

At this state an user can `browseURL(tpapp$url("/login"))` and allow the third-party app access to their account.
Once they have done that they get a token.

## With httr's OAuth tools

### OAuth2.0 app creation & registration

What's crucial here is setting `httr::oauth_callback()` as redirect URI, which is what you do when creating an app for rtweet for instance.

``` {r httr}
url <- paste0(
  regi_url,
  "?name=3P%20app2",
  "&redirect_uri=", httr::oauth_callback()
)
reg_resp <- httr::GET(url)
reg_resp
regdata <- httr::content(reg_resp)
regdata
```

Now we can launch the token creation.
This can only be done interactively

```{r httr-dance, eval = FALSE}
app <- httr::oauth_app(
  "3P app2",
  key = regdata$client_id[[1]],
  secret = regdata$client_secret[[1]],
  redirect_uri = httr::oauth_callback()
)

endpoint <- httr::oauth_endpoint(
  authorize = auth_url,
  access = toke_url
)

token <- httr::oauth2.0_token(
  endpoint, app
)

```

## Applications

With these apps, or only the resource server app, you can now test your code that helps users create and store an OAuth2.0 token.
The token can also be used as fake token when you use mocking (with vcr or httptest) in your tests (the fake token could be used on continuous integration for instance).

## Future work

It might be interesting for the server app to
* have some sort of data endpoint (needing authentication with an access token, and taking the token expiry into account)
* have a refresh endpoint.
